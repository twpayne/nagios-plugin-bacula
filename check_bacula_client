#!/usr/bin/env python
#
#   check_bacula_client  Nagios plugin to check Bacula client backups
#   Copyright (C) 2010  Tom Payne
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.


from datetime import datetime, timedelta
from optparse import OptionParser
import re
import sys
import time

import pexpect


OK, WARNING, CRITICAL, UNKNOWN = xrange(0, 4)
status_message = 'OK WARNING CRITICAL UNKNOWN'.split()


def main(argv):
    parser = OptionParser()
    parser.add_option('-H', metavar='ADDRESS', dest='host')
    parser.add_option('-w', metavar='HOURS', type=int, dest='warning')
    parser.add_option('-c', metavar='HOURS', type=int, dest='critical')
    options, args = parser.parse_args(argv[1:])
    exit_status, message = OK, None
    child = pexpect.spawn('/usr/sbin/bconsole', ['-n'])
    try:
        child.expect(r'\n\*')
        child.sendline('status client')
        child.expect(r'Select Client \(File daemon\) resource \(\d+-\d+\): ')
        index = None
        r = re.compile(r'\s*(\d+):\s+%s' % re.escape(options.host))
        for line in child.before.splitlines():
            m = r.match(line)
            if m:
                index = int(m.group(1))
        if index is None:
            raise RuntimeError('unknown client %s' % options.host)
        child.sendline(str(index))
        child.expect('Terminated Jobs:')
        child.expect(r'\n\*')
        r = re.compile(r'\s*(\d+)\s+(\S+)\s+(\S+)\s+(\d+\.\d+\s+[KMGTP]|0)\s+OK\s+(\S+\s+\S+)\s+%s' % re.escape(options.host))
        job_id = level = files = bytes = finished = None
        for line in child.before.splitlines():
            m = r.match(line)
            if m:
                job_id = int(m.group(1))
                level = m.group(2)
                files = int(re.sub(r',', '', m.group(3)))
                bytes = re.sub(r'\s+', '', m.group(4))
                finished = datetime(*(time.strptime(m.group(5), '%d-%b-%y %H:%M')[0:6]))
        if job_id is None:
            raise RuntimeError('no terminated jobs')
        age = datetime.now() - finished
        if options.warning and age > timedelta(seconds=3600 * options.warning):
            exit_status = WARNING
        if options.critical and age > timedelta(seconds=3600 * options.critical):
            exit_status = CRITICAL
        message = '%s, %d files, %sB, %s (%d hours ago)' % (level, files, bytes, finished, 24 * age.days + age.seconds / 3600)
    except RuntimeError:
        exit_status, message = (CRITICAL, [str(sys.exc_info()[1])])
    child.sendeof()
    child.expect(pexpect.EOF)
    print '%s: %s' % (status_message[exit_status], message)
    sys.exit(exit_status)


if __name__ == '__main__':
    main(sys.argv)
